# Podman 运行 MySQL

## Podman 介绍及安装

简单地，可以理解为无守护进程的容器管理工具。具体可参考[红帽的这篇文章](https://www.redhat.com/zh/topics/containers/what-is-podman)

![](./screenshot1.png)

针对我们自己的需求，主要考虑以下几个方面

- 可以运行无根容器，避免特权账号带来的安全隐患
- 兼容 Docker 镜像与 CLI 命令，很少迁移成本
- 可借助 REST API 更方便地管理容器

安装时，可使用各发行版的包管理工具安装。如在 Rocky Linux 中，

```shell
sudo dnf install podman
```

## 通过 Podman 运行 MySQL

### 直接运行

Podman 兼容 Docker 的 CLI 命令，与 Docker 类似，可使用以下命令在容器中运行 MySQL，考虑数据安全和后期配置方便，将数据目录和配置目录挂载出来。

```shell
podman run -d --name mysql-master -p 3306:3306 -v /home/zhang/mysql/master/data:/var/lib/mysql -v /home/zhang/mysql/master/config:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 mysql:8 --default-authentication-plugin=mysql_native_password
```

### 问题理解及解决思路

通过以上命令运行的 MySQL 初次使用并无问题，通过各类数据库连接工具进行测试也都正常。可第二天再来发现`podman ps`就报错了，且查不到任何运行中的容器；通过数据库客户端也无法连接。

报错信息大致为

```shell
Error refreshing container xxx: error acquiring lock 0 for container xxx: file exists
```

我以 `podman error acquiring lock for container` 为关键字在谷歌搜索，发现了 Gayhub 上的[这个 issue](https://github.com/containers/podman/issues/13240) 从讨论中可以看到，用户登出后，systemd 清理了 Podman 的临时文件目录。这也解释了为什么首次测试时一切正常 —— 那时候我一直远程登录，并未触发登出后事件。

Podman 作为无守护进程的容器管理工具，在用户登出后会自动退出，这看起来是很容易理解的。那么可否使用其他思路来创建一个守护呢？还是在上文提到的红帽文章中，提到了

> 通过将 systemd 和 Podman 集成，您可以为容器生成控制单元，并在自动启用 systemd 的前提下运行它们。

于是总体的解决思路即为——创建 Podman 用户级服务、服务自启动设置。

## 注册并设置 Podman 用户服务

### 注册用户服务

Podman 提供了`podman generate systemd` 命令，可以生成指定容器的 systemd 配置文件，针对我们的容器，使用以下命令：

```shell
podman generate systemd --files --name mysql-master
```

其中，--files 参数表示在当前目录下生成文件，而不是输出到 STDOUT；--name 参数表示使用后面给的作为服务名称的命名规则（比如这里生成的服务名即为 container-mysql-master）； 有些文章提到还有一个- -new 参数，如果设置了这个参数，则服务停止时容器也删除掉了，这不符合我们的需求，所以我这里没有添加

最终生成的文件如下

```service
# container-mysql-master.service
# autogenerated by Podman 4.2.0
# Mon Feb 20 21:14:13 CST 2023

[Unit]
Description=Podman container-mysql-master.service
Documentation=man:podman-generate-systemd(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor=/run/user/1000/containers

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
TimeoutStopSec=70
ExecStart=/usr/bin/podman start mysql-master
ExecStop=/usr/bin/podman stop -t 10 mysql-master
ExecStopPost=/usr/bin/podman stop -t 10 mysql-master
PIDFile=/run/user/1000/containers/overlay-containers/xxx/userdata/conmon.pid
Type=forking

[Install]
WantedBy=default.target
```

将文件移动到 `.config/systemd/user` 目录，便可以通过 systemctl 命令进行用户级服务操作

```shell
systemctl --user start container-mysql-master.service
systemctl --user status container-mysql-master.service
systemctl --user stop container-mysql-master.service
```

同时，可以发现，stop 了服务后，podman 显示，容器也停止了，但并没有被删除，符合要求。

### 设置自动启动

通过 systemd 设置自动启动，很自然地写法即为 enable

```shell
systemctl --user enable container-mysql-master.service
```

重启系统后，直接在远程连接数据库（测试环境，开放了相关端口），发现无法连接；远程连接 SSH 查看问题时，发现又能够连接了，这是怎么一回事呢？

根据[Arch Wiki](https://wiki.archlinux.org/title/systemd/User) 中的说法：

> As per default configuration in `/etc/pam.d/system-login`, the `pam_systemd` module automatically launches a `systemd --user` instance when the user logs in for the first time. This process will survive as long as there is some session for that user, and will be killed as soon as the last session for the user is closed.

也就是说，这种用户级的服务在用户首次登录时自动启动，在用户都登出后也就被杀掉了。

为解决这个问题，需要使用以下命令

```
loginctl enable-linger
```

根据 man 文档的解释

> Enable/disable user lingering for one or more users. If enabled for a specific user, a user manager is spawned for the user at boot and kept around after logouts. This allows users who are not logged in to run long-running services. Takes one or more user names or numeric UIDs as argument. If no argument is specified, enables/disables lingering for the user of the session of the caller.

也就是说，可以设置用户的开机启动（而不是登录启动）、后台驻留。

这样设置后，我们直接重启服务器，不必远程登陆，发现已经可以通过数据库客户端远程操作。至此，实现了 Podman 运行 MySQL，并注册为可自动启动的用户级服务。
